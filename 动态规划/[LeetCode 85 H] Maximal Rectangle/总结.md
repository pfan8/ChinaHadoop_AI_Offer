## 解题思路

1. 动态规划：假设行数`m`，宽度为`n`
    + 思路：一维dp数组，长度为`n`，遍历每一行的时候，dp数组记录所在行数向上有多少个连续的1，例如`[0,0,3,0,0]`，表示第三列上面有3个连续的1，其他位置上面可能有1，但是不连续，当前行只能记为0（其实二维dp数组也能实现，一维则更节省空间），记录完一行的dp数组之后，利用stack，从dp数组计算得到当前行元素为底的最大的矩形面积。具体过程为：
        1. 遍历dp数组，如果stack为空或者当前元素`>=`栈顶元素，则压入当前元素，注意要压入索引，而不是值，便于后续计算（如此能保证stack[i]到stack[i+1]之间至少有dp[stack[i+1]]的高度）
        2. `while`当前元素`<`栈顶元素，不断出栈，并计算
        $$
        RectArea = \begin{cases}
        max(RectArea, dp[stack.pop()]*当前索引) \quad pop之后栈为空 \\
        max(RectArea,dp[stack.pop()]*(当前索引-stack.peek()-1)) \quad pop之后栈飞空
        \end{cases}
        $$
        3. 循环结束之后，如果stack非空，则按照上式流程，不断出栈并计算最大面积，其中`当前索引`改为`dp数组长度`

    + 时间复杂度：$$O(M*N)$$，M为行，N为列
    + 空间复杂度：$$O(N)$$

最后想总结一下，该题花费了较长时间，主要在debug过程，stack的遍历过程不断出错，后面我想了一下，以后碰到类似的题目，应该尽量降低问题的维度，以该题为例：将原二维数组转换为一维数组，降低到每一行一维数组来处理，能降低复杂度；stack其实也是一样的思想，在遍历过程中，将一维的dp数组再次压缩，每次处理只用考虑栈顶元素即可，因此可以将其理解为从一维降低到零维，所以核心思想是不断降维，降低问题复杂度，细化思考问题的粒度和范围，应该能降低犯错概率。