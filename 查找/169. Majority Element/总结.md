## 解题思路
找众数，题目很清晰，由于定义众数出现[n/2]次以上，解法其实有很多种：
1. HashMap计数，当有数字次数到达[n/2]时，返回结果
    + 时间复杂度：$O(n)$
    + 空间复杂度：$O(n)$
2. 排序，然后取[n/2]的位置，就是众数
    + 时间复杂度：$O(nlogn)$
    + 空间复杂度：$O(1)$
3. 随机选一个数，很可能就是众数，对选的数遍历数组count，达到[n/2]则返回结果
    + 时间复杂度：$O(\infty)$，看脸，但概率上来说很容易1,2次就取到众数
    + 空间复杂度：$O(1)$
4. Boyer-Moore投票算法：
    1. 选取第一个数为候选者
    2. 遍历下去，如果和候选者相同，则votesum加1，否则减1
    3. 如果votesum==0，则选择当前数字为新的候选者
    
    以`[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]`为例，`|`表示重置位置
    
    因为众数$\geq$[n/2]，因此当votesum为0，重置清除了左边众数和非众数，但是因为众数的次数是超过[n/2]的，因此最后肯定剩下众数
    + 时间复杂度：$O(n)$
    + 空间复杂度：$O(1)$