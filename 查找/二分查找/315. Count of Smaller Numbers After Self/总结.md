## 解题思路
1. 时间复杂度要求在$O(nlog(n))$内，不然会TLE，因此考虑使用二分查找：

    + 构建一个辅助数组arr，记录已出现元素，并按大小排序，每次遍历nums中的一个元素，便将新元素插入相应的位置
    + nums数组逆序遍历，并在arr中采用二分查找，寻找当前元素，假设arr中找到的位置为mid，从而该位置的计数为len(arr)-mid
    + 将计数依次添加进res数组，在nums遍历结束后，返回res结果
    + 时间复杂度$O(nlog(n))$
    + 空间复杂度$O(n)$，arr数组和res数组

2. 用python的bisect库，其实底层也是用二分查找的思想，但是做了不少优化，另外用append替代insert，最后用切片翻转测试时间会降不少
    + 时间复杂度$O(nlog(n))$
    + 空间复杂度$O(n)$