## 解题思路

1. 使用最大堆，从左上角进行DFS，如果往下或者或右的下一个值比另一个方向小，则一直走下去，直到比另一个方向的下一个值大
   + 时间复杂度：$O(nlogk)$，插入堆$O(logk)$，遍历$O(n)$
   + 空间复杂度：$O(k)$
2. 使用二分查找：因为矩阵是有序的，因此第k个值一定在`matrix[0][0]`到`matrix[n-1][n-1]`之间，因此不断二分取`mid`，统计比`mid`小的个数`cnt`，根据`cnt`更新`lo`或者`hi`。

    **注意：要等到lo==hi时再返回lo，因为mid可能是不存在的**
    + 时间复杂度：$O(nlogn)$，查找$O(logn)$，计数$O(n)$
    + 空间复杂度：$O(1)$