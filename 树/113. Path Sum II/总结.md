## 解题思路

1. 可以使用递归实现DFS，累加curLen，添加当前元素进入结果，如果走到叶节点，`curLen==sum`，则可以添加这条结果v到res里，但是v每次递归都得复制，因此空间开销较大

+ 时间复杂度：$O(n)$，最差情况要遍历所有节点
+ 空间复杂度：$O(nlogn)$，最差情况v记录所有路径，双边，重复记录，$\frac{n}{2}*logn$

2. 用Stack实现DFS

+ 时间复杂度：$O(n)$，最差情况要遍历所有节点
+ 空间复杂度：$O(n)$，最差情况stack存储所有节点

3. 用Queue实现BFS，BFS按层遍历，如果某一层curLen结果大于sum，则返回取消这个分支，否则将子节点继续添加到Queue中，但是curLen和v同样要冗余多份，用2个vector记录，因此空间开销同样大

+ 时间复杂度：$O(n)$，最差情况要遍历所有节点
+ 空间复杂度：$O(nlogn)$，最差情况记录vector存储所有路径，双边，重复记录，$\frac{n}{2}*logn$

