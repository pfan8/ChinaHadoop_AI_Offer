## 解题思路
假设`s1`长度为`l1`，`s2`长度为`l2`
1. **递归（Brute Force）**：DFS搜索，当`s1`和`s2`的当前字符都能和`s3`匹配时，分支去递归查询结果，并用or连接递归结果

 + 时间复杂度：$O(l1*l2)$，每个位置都可能分支出去
 + 空间复杂度：$O(l1+l2)$，递归栈个数最多为l1+l2，即长度不会超过`s3`的长度

2. **递归+memo**：第一种办法在搜索过程中重复了后续的一些同样判断，因此可以考虑采用memo的方式保存已经判断的结果

 + 时间复杂度：$O(l1*l2)$，每种情况都没遇见过，memo为空
 + 空间复杂度：$O(l1*l2)$，memo空间

1. **2-D数组动态规划**：从`prefix`前缀的角度思考，假设`s1`的第i个位置和s2的第j个位置之前都已经判断好了，那么
$$
dp[i][j] = \begin{cases}
s1[i-1]==s3[i+j-1], \quad dp[i-1][j] == True\\
s2[j-1]==s3[i+j-1], \quad dp[i][j-1] == True
\end{cases}
$$

 + 时间复杂度：$O(l1*l2)$，设定数组的每一个值，遍历一遍就是`l1*l2`
 + 空间复杂度：$O(l1*l2)$，dp空间

1. **1-D数组动态规划**：由于数组更新是顺序的，可以优化为1D（背包）

 + 时间复杂度：$O(l1*l2)$
 + 空间复杂度：$O(max(l1,l2))$，看你选定的数组长度是`l1`还是`l2`
