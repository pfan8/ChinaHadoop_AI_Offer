## 解题思路
要让时间复杂度在$O(nlogn)$，就必须采用对应的排序算法，由于数据结构是Linked List，因此只能采用merge sort，具体实现方式有两种：

1. 自顶向下：采用递归的方式，不断向下二分链表，知道链表长度为1，然后返回拼接2个链表的结果
    + 时间复杂度：$O(nlogn)$
    + 空间复杂度：$O(logn)$，因为递归函数会消耗内存
2. 自底向上：利用指标interval控制当前merge的链表大小，每次循环merge乘2，直至merge大于1/2链表长度
    + 时间复杂度：$O(nlogn)$
    + 空间复杂度：$O(1)$
3. 遍历，将链表的val值保存在数组中，然后对数组排序，再遍历链表修改每个节点的val值
    + 时间复杂度：$O(nlogn)$
    + 空间复杂度：$O(n)$ 

看上去第三种方法较慢，但事实上用python内置的sorted排序很快，应该是cyphon优化的原因，另外空间消耗也比上面两种低，推测是构建merge边界的时候，需要处理node，从而增加了空间消耗，还不如用val的数组消耗低